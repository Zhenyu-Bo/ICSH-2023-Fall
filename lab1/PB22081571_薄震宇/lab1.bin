0011 0000 0000 0000     ;start the program at loaction x3000
0010 001 011111111      ;从x3100中取n放到R1中，PCoffset=x3100-x3001=255
0010 101 011111111      ;从x3101中去学号最后一位放到R5中
0101 000 000 1 00000    ;RO清零，记录n或n-1的二进制表示中1的位数
0101 010 010 1 00000    ;R2清零，存放n/2的值
0001 011 001 1 00000    ;R3中也存放n的值
0101 100 100 1 00000    ;R4清零，记录n的奇偶性，R4=1时为偶数，R4=0时为奇数
0001 011 011 1 11110    ;R3=R3-2
0000 011 111111110      ;如果R3非负，跳转到R3=R3-2
0001 011 011 1 00010    ;R3=R3+2
0000 001 000000010      ;如果R3大于0即R3=1,说明n为奇数，不需要减1，跳过后面两条指令
0001 001 001 1 11111    ;如果R3=0，说明n为偶数，需要计算n-1的原码中1的数目即为-n的补码中0的数目
0001 100 100 1 00001    ;R4赋值为1，以表示n为偶数
0001 001 001 1 11110    ;R1=R1-2
0000 100 000000010      ;如果R1<0，跳转至R1=R1+2
0001 010 010 1 00001    ;R2=R2+1
0000 111 111111100      ;无条件跳转至R1=R1-2
0001 001 001 1 00010    ;R1=R1+2
0000 010 000000001      ;R1=0则跳转至判断R2是否为0
0001 000 000 1 00001    ;R1不等于0则等于1，说明余数为1，R0自加1
0001 010 010 1 00000    ;R2=R2+0,改变nzp使其与R2中的值相关
0000 010 000000011      ;R2=0则count计算完毕，跳转至后续处理过程
0001 001 010 1 00000    ;R1=R2
0101 010 010 1 00000    ;R2=0
0000 111 111110100      ;无条件跳转至R1=R1-2
0001 100 100 1 00000    ;R4=R4+0,改变nzp使其与R4中的值相关
0000 001 000000011      ;R4>0说明n为偶数，R0中的值即为-n的二进制补码中0的数目,跳过后面三条指令
1001 000 000 111111     ;R0取反
0001 000 000 1 00010    ;R0=R0+2,即将原R0中的数目取反加1再加1
0001 000 000 1 01111    ;R0=R0+14，分两次完成了16-R0,由于立即数范围的限制，第一步将R0取反加2而不是加1
0001 000 000 0 00 101   ;R0=R0+R5
0011 000 011100011      ;将R0中的结果存到x3102中
1111 0000 00100101      ;halt